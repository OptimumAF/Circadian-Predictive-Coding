"""Generate README charts and animation from benchmark outputs.

This script intentionally uses Pillow instead of matplotlib to keep figure
generation stable in environments where compiled plotting dependencies may be
unavailable.
"""

from __future__ import annotations

import argparse
import csv
from dataclasses import dataclass
from pathlib import Path
from typing import Any

from PIL import Image, ImageDraw, ImageFont


@dataclass(frozen=True)
class SummaryRow:
    model_name: str
    test_accuracy_mean: float
    train_samples_per_second_mean: float
    inference_latency_p95_ms_mean: float
    balanced_score: float


MODEL_ORDER = ["BackpropResNet50", "PredictiveCodingResNet50", "CircadianPredictiveCodingResNet50"]
MODEL_LABELS = {
    "BackpropResNet50": "Backprop",
    "PredictiveCodingResNet50": "Predictive",
    "CircadianPredictiveCodingResNet50": "Circadian",
}
MODEL_COLORS = {
    "BackpropResNet50": (46, 97, 173),
    "PredictiveCodingResNet50": (61, 157, 86),
    "CircadianPredictiveCodingResNet50": (189, 102, 36),
}


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate README benchmark figures.")
    parser.add_argument(
        "--summary-csv",
        type=str,
        default="benchmark_multiseed_cifar100_summary.csv",
        help="Path to the summary CSV generated by run_multiseed_resnet_benchmark.py",
    )
    parser.add_argument(
        "--output-dir",
        type=str,
        default="docs/figures",
        help="Directory to write figure artifacts.",
    )
    parser.add_argument(
        "--sleep-cycles",
        type=int,
        default=24,
        help="Cycle count for the illustrative circadian GIF timeline.",
    )
    parser.add_argument(
        "--start-hidden",
        type=int,
        default=384,
        help="Starting hidden dimension for the illustrative circadian GIF timeline.",
    )
    parser.add_argument(
        "--splits",
        type=int,
        default=12,
        help="Total split events represented in the illustrative circadian GIF timeline.",
    )
    parser.add_argument(
        "--prunes",
        type=int,
        default=2,
        help="Total prune events represented in the illustrative circadian GIF timeline.",
    )
    return parser.parse_args()


def load_summary_rows(path: Path) -> list[SummaryRow]:
    if not path.exists():
        raise FileNotFoundError(f"Summary CSV does not exist: {path}")

    rows_by_model: dict[str, SummaryRow] = {}
    with path.open("r", encoding="utf-8", newline="") as handle:
        reader = csv.DictReader(handle)
        for raw in reader:
            model_name = str(raw["model_name"])
            rows_by_model[model_name] = SummaryRow(
                model_name=model_name,
                test_accuracy_mean=float(raw["test_accuracy_mean"]),
                train_samples_per_second_mean=float(raw["train_samples_per_second_mean"]),
                inference_latency_p95_ms_mean=float(raw["inference_latency_p95_ms_mean"]),
                balanced_score=float(raw.get("balanced_score", "0.0")),
            )

    missing = [name for name in MODEL_ORDER if name not in rows_by_model]
    if missing:
        raise ValueError(f"Missing models in summary CSV: {missing}")
    return [rows_by_model[name] for name in MODEL_ORDER]


def draw_bar_chart(
    rows: list[SummaryRow],
    title: str,
    subtitle: str,
    value_getter: Any,
    value_formatter: Any,
    output_path: Path,
    higher_is_better: bool = True,
) -> None:
    width = 1280
    height = 720
    image = Image.new("RGB", (width, height), (248, 250, 252))
    draw = ImageDraw.Draw(image)
    font_title = ImageFont.load_default()
    font_body = ImageFont.load_default()

    draw.text((50, 28), title, fill=(20, 20, 24), font=font_title)
    draw.text((50, 52), subtitle, fill=(90, 94, 103), font=font_body)

    left = 100
    top = 110
    right = width - 80
    bottom = height - 120
    chart_height = bottom - top
    chart_width = right - left
    draw.rectangle([(left, top), (right, bottom)], outline=(215, 220, 228), width=2)

    values = [float(value_getter(row)) for row in rows]
    max_value = max(values)
    min_value = min(values)
    span = max(max_value - min_value, 1e-8)

    for index, row in enumerate(rows):
        value = float(value_getter(row))
        x0 = left + int((index + 0.15) * chart_width / len(rows))
        x1 = left + int((index + 0.85) * chart_width / len(rows))
        if higher_is_better:
            ratio = value / max(max_value, 1e-8)
        else:
            ratio = (max_value - value) / span
        bar_height = max(int(chart_height * ratio), 3)
        y0 = bottom - bar_height
        y1 = bottom

        draw.rectangle([(x0, y0), (x1, y1)], fill=MODEL_COLORS[row.model_name], outline=(40, 40, 44))
        draw.text((x0, bottom + 12), MODEL_LABELS[row.model_name], fill=(20, 20, 24), font=font_body)
        draw.text((x0, y0 - 16), value_formatter(value), fill=(20, 20, 24), font=font_body)

    draw.text(
        (50, height - 42),
        "Source: benchmark_multiseed_cifar100_summary.csv",
        fill=(120, 124, 132),
        font=font_body,
    )
    output_path.parent.mkdir(parents=True, exist_ok=True)
    image.save(output_path, format="PNG")


def build_delta_sequence(cycles: int, splits: int, prunes: int) -> list[int]:
    if cycles <= 0:
        raise ValueError("cycles must be positive.")
    deltas = [0 for _ in range(cycles)]

    if splits > 0:
        split_positions = evenly_spaced_positions(cycles=cycles, count=splits, from_start=True)
        for index in split_positions:
            deltas[index] += 1
    if prunes > 0:
        prune_positions = evenly_spaced_positions(cycles=cycles, count=prunes, from_start=False)
        for index in prune_positions:
            deltas[index] -= 1
    return deltas


def evenly_spaced_positions(cycles: int, count: int, from_start: bool) -> list[int]:
    if count <= 0:
        return []
    positions: list[int] = []
    for i in range(count):
        ratio = (i + 1) / (count + 1)
        base = int(round(ratio * (cycles - 1)))
        positions.append(base)
    positions = sorted(set(positions))
    while len(positions) < count:
        next_pos = len(positions) % cycles
        if next_pos not in positions:
            positions.append(next_pos)
    positions = sorted(positions[:count])
    if from_start:
        return positions
    return [cycles - 1 - position for position in positions]


def make_hidden_series(start_hidden: int, deltas: list[int]) -> list[int]:
    values = [start_hidden]
    current = start_hidden
    for delta in deltas:
        current += delta
        values.append(current)
    return values


def draw_circadian_gif(
    output_path: Path,
    start_hidden: int,
    sleep_cycles: int,
    splits: int,
    prunes: int,
) -> None:
    deltas = build_delta_sequence(cycles=sleep_cycles, splits=splits, prunes=prunes)
    hidden_values = make_hidden_series(start_hidden=start_hidden, deltas=deltas)
    min_hidden = min(hidden_values)
    max_hidden = max(hidden_values)
    value_span = max(max_hidden - min_hidden, 1)

    width = 960
    height = 540
    left = 80
    right = width - 60
    top = 90
    bottom = height - 90
    chart_width = right - left
    chart_height = bottom - top

    frames: list[Image.Image] = []
    for frame_index in range(len(hidden_values)):
        image = Image.new("RGB", (width, height), (250, 251, 253))
        draw = ImageDraw.Draw(image)
        font = ImageFont.load_default()
        draw.text((36, 24), "Circadian Sleep Dynamics (Illustrative)", fill=(20, 20, 24), font=font)
        draw.text(
            (36, 44),
            "Wake updates chemicals; sleep cycles trigger split/prune adaptation.",
            fill=(92, 96, 104),
            font=font,
        )

        draw.rectangle([(left, top), (right, bottom)], outline=(212, 217, 224), width=2)
        for tick in range(5):
            y = top + int(tick * chart_height / 4)
            draw.line([(left, y), (right, y)], fill=(236, 239, 244), width=1)

        points: list[tuple[int, int]] = []
        for idx in range(frame_index + 1):
            x = left + int(idx * chart_width / max(len(hidden_values) - 1, 1))
            normalized = (hidden_values[idx] - min_hidden) / value_span
            y = bottom - int(normalized * chart_height)
            points.append((x, y))
        if len(points) > 1:
            draw.line(points, fill=(189, 102, 36), width=4)
        if points:
            px, py = points[-1]
            draw.ellipse([(px - 5, py - 5), (px + 5, py + 5)], fill=(189, 102, 36), outline=(70, 40, 18))

        current_cycle = frame_index
        hidden_now = hidden_values[frame_index]
        draw.text(
            (36, height - 58),
            f"Cycle {current_cycle:02d}/{sleep_cycles:02d} | hidden_dim={hidden_now} | splits={splits} | prunes={prunes}",
            fill=(22, 22, 26),
            font=font,
        )
        draw.text((36, height - 38), "Illustrative animation (not a direct training trace).", fill=(112, 116, 124), font=font)
        frames.append(image)

    output_path.parent.mkdir(parents=True, exist_ok=True)
    first, *rest = frames
    first.save(
        output_path,
        format="GIF",
        save_all=True,
        append_images=rest,
        duration=260,
        loop=0,
    )


def main() -> None:
    args = parse_args()
    summary_path = Path(args.summary_csv)
    output_dir = Path(args.output_dir)
    rows = load_summary_rows(summary_path)

    draw_bar_chart(
        rows=rows,
        title="Accuracy Comparison (Higher Is Better)",
        subtitle="Mean test accuracy across multi-seed CIFAR-100 benchmark",
        value_getter=lambda row: row.test_accuracy_mean,
        value_formatter=lambda value: f"{value:.3f}",
        output_path=output_dir / "benchmark_accuracy.png",
        higher_is_better=True,
    )
    draw_bar_chart(
        rows=rows,
        title="Training Throughput (Higher Is Better)",
        subtitle="Mean training samples per second",
        value_getter=lambda row: row.train_samples_per_second_mean,
        value_formatter=lambda value: f"{value:.0f}",
        output_path=output_dir / "benchmark_train_speed.png",
        higher_is_better=True,
    )
    draw_bar_chart(
        rows=rows,
        title="Inference Latency P95 (Lower Is Better)",
        subtitle="Mean p95 inference latency in milliseconds",
        value_getter=lambda row: row.inference_latency_p95_ms_mean,
        value_formatter=lambda value: f"{value:.2f} ms",
        output_path=output_dir / "benchmark_inference_latency_p95.png",
        higher_is_better=False,
    )
    draw_circadian_gif(
        output_path=output_dir / "circadian_sleep_dynamics.gif",
        start_hidden=args.start_hidden,
        sleep_cycles=args.sleep_cycles,
        splits=args.splits,
        prunes=args.prunes,
    )
    print(f"Wrote figures to {output_dir}")


if __name__ == "__main__":
    main()
